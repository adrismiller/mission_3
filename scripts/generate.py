import cv2
import os
import numpy as np

from scripts import state, markov_chain

# defaults for ImgGenerator functions
DEFAULT_FILE_TYPE = ".jpeg"
DEFAULT_IMG_SIZE = 300

# defaults for main method
DEFAULT_OUTPUT_DIR = "outputs"
DEFAULT_OUTPUT_FILENAME = 'example.jpeg'
DEFAULT_IMG_DIMS = 20
DEFAULT_SEQUENCE_LENGTH = 400

PRIOR = [.15, .15, .15, .15, .15, .15, .02, .02, .02, .02, .02]
DOG_NAMES = ["rosie", "callie", "venus", "bear", "jamie", "cooper", "winston", "bruno", "maisy",
             "speedy", "bella"]

ROSIE_TRANSITION = [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
CALLIE_TRANSITION = [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
VENUS_TRANSITION = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
BEAR_TRANSITION = [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
JAMIE_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0]
COOPER_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0]
WINSTON_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]
BRUNO_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]
MAISY_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]
SPEEDY_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]
BELLA_TRANSITION = [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]


class ImgGenerator:
    """
    Class that given information about a image to be created, generates the image and exports to given
    output path. Uses cv2 and numpy to essentially create a collage of images based on the order specified by
    a unique generated Markov Chain.

    :param: State[] all_states: vector containing all possible State objects for the image to be generated
    :param: State[] order:  vector containing the order (generated by MarkovChain) of state objects for the image
    :param: str input_dir:  the directory containing input images
    :param str output_path: path that random image should be exported to
    :param int num_rows: number of rows that image will contain

    """

    def __init__(self, all_states, order, input_dir, output_path, num_rows, num_cols):
        self.all_states = all_states
        self.order = order
        self.input_dir = input_dir
        self.output_path = output_path
        self.num_rows = num_rows
        self.num_cols = num_cols

    def get_all_imgs(self):
        """
        Helper function for generate_img -- returns all the cv2 image objects for each state in the same order that
        they appear in self.all_states. Used in self.generate_img as a cache to retrieve image objects without having
        to reread in image every time it reappears (images repeat often in this model)

        :return: im[] all_imgs: list of cv2 image objects
        """
        all_imgs = []

        # for all possible states
        for s in self.all_states:
            # add file type to name of state object
            filename = s.name + DEFAULT_FILE_TYPE
            # join path of input directory and filename for image
            img_path = os.path.join(self.input_dir, filename)
            # read image in and resize to default
            img = cv2.imread(img_path)
            img = cv2.resize(img, (DEFAULT_IMG_SIZE, DEFAULT_IMG_SIZE))
            # add image to all_imgs
            all_imgs.append(img)

        return all_imgs

    def generate_img(self):
        """
        Generates an collage image based on Markov Chain and exports to appropriate output directory

        :return:
        """
        # TODO : add check for dimensions of picture being good

        index = 0
        # retrieve an accesible list of image objects that will be used
        all_imgs = self.get_all_imgs()
        all_rows = []
        # create num_rows rows
        for r in range(self.num_rows):
            current_row = []
            # each row is of length num_cols
            for c in range(self.num_cols):
                # access id of current state in the order
                current_state_id = self.order[index].id
                # retrieve the image corresponding to that states id
                current_row.append(all_imgs[current_state_id])
                index += 1
            # create horizontal stack (eg row) of images
            current_row = np.hstack(current_row)
            all_rows.append(current_row)

        # concatenate rows into finale image
        img = np.vstack(all_rows)

        # export image to output_path
        cv2.imwrite(self.output_path, img)


def main():
    # current working directory minus "scripts"
    cwd = os.getcwd()[:-7]

    dog_names = DOG_NAMES

    # probability of the first pixel (upper left corner) is each dog
    prior = PRIOR

    # transition matrix
    transition = [ROSIE_TRANSITION, CALLIE_TRANSITION, VENUS_TRANSITION, BEAR_TRANSITION, JAMIE_TRANSITION,
                  COOPER_TRANSITION, WINSTON_TRANSITION, BRUNO_TRANSITION, MAISY_TRANSITION, SPEEDY_TRANSITION,
                  BELLA_TRANSITION]

    all_states = []

    # create State object for each dog in dog names
    for i, dog in enumerate(dog_names):
        new_state = state.State(id=i, name=dog)
        all_states.append(new_state)

    # run markov chain using states, prior probability vector, and transition matrix
    m = markov_chain.MarkovChain(states=all_states, prior=prior, transition=transition)
    sequence = m.run(sequence_length=DEFAULT_SEQUENCE_LENGTH)

    # create output_path variable
    output_path = os.path.join(cwd, DEFAULT_OUTPUT_DIR)
    output_path = os.path.join(output_path, DEFAULT_OUTPUT_FILENAME)

    # generate image from markov chain, input images, and output_path
    i = ImgGenerator(order=sequence, input_dir=os.path.join(cwd, "photos"), output_path=output_path,
                     num_rows=DEFAULT_IMG_DIMS,
                     num_cols=DEFAULT_IMG_DIMS, all_states=all_states)
    i.generate_img()


if __name__ == '__main__':
    main()
