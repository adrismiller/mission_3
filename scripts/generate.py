import cv2
import os
import argparse
import numpy as np

from state import State
from markov_chain import MarkovChain

# defaults for ImgGenerator functions
FILE_TYPE = ".jpeg"
IMG_SIZE = 300

# defaults for main method
INPUT_DIR = "assets"
OUTPUT_DIR = "examples"
OUTPUT_FILENAME = 'example.jpeg'
IMG_DIMS = 20

PRIOR = [.13, .13, .13, .13, .13, .13, .01, .01, .01, .01, .01, 0.09, 0.08]
DOG_NAMES = ["rosie", "callie", "venus", "bear", "jamie", "cooper", "winston", "bruno", "maisy",
             "speedy", "bella", "boomer", "sasha"]

ROSIE_TRANSITION = [0.0, 0.6, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
CALLIE_TRANSITION = [0.6, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
VENUS_TRANSITION = [0.0, 0.2, 0.0, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4]
BEAR_TRANSITION = [0.1, 0.1, 0.4, 0.1, 0.0, 0.1, 0.0, 0.1, 0.0, 0.1, 0.0, 0.0, 0.0]
JAMIE_TRANSITION = [0.3, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.1, 0.1, 0.1, 0.0]
COOPER_TRANSITION = [0.1, 0.5, 0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.1, 0.0, 0.0, 0.1]
WINSTON_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.1, 0.1, 0.1, 0.1, 0.1]
BRUNO_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.1, 0.1, 0.1, 0.1, 0.1]
MAISY_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]
SPEEDY_TRANSITION = [0.0, 0.1, 0.0, 0.0, 0.0, 0.1, 0.1, 0.1, 0.0, 0.0, 0.5, 0.0, 0.1]
BELLA_TRANSITION = [0.0, 0.0, 0.0, 0.0, 0.1, 0.1, 0.1, 0.0, 0.1, 0.5, 0.0, 0.1, 0.0]
BOOMER_TRANSITION = [0.1, 0.1, 0.1, 0.1, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5]
SASHA_TRANSITION = [0.1, 0.1, 0.1, 0.1, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0]


class ImgGenerator:
    """
    Class that given information about a image to be created, generates the image and exports to given
    output path. Uses cv2 and numpy to essentially create a collage of images based on the order specified by
    a unique generated Markov Chain.

    :param: State[] all_states: vector containing all possible State objects for the image to be generated
    :param: State[] order:  vector containing the order (generated by MarkovChain) of state objects for the image
    :param: str input_dir:  the directory containing input images
    :param str output_path: path that random image should be exported to
    :param int num_rows: number of rows that image will contain
    :param int num_rows: number of columsn that image will contain
    """

    def __init__(self, all_states, order, input_dir, output_path, num_rows, num_cols):
        self.all_states = all_states
        self.order = order
        self.input_dir = input_dir
        self.output_path = output_path
        self.num_rows = num_rows
        self.num_cols = num_cols

    def get_all_imgs(self):
        """
        Helper function for generate_img -- returns all the cv2 image objects for each state in the same order that
        they appear in self.all_states. Used in self.generate_img as a cache to retrieve image objects without having
        to reread in image every time it reappears (images repeat often in this system)

        :return: im[] all_imgs: list of cv2 image objects
        """
        all_imgs = []

        # for all possible states
        for s in self.all_states:
            # add file type to name of state object
            filename = s.name + FILE_TYPE
            # join path of input directory and filename for image
            img_path = os.path.join(self.input_dir, filename)
            # read image in and resize to default
            img = cv2.imread(img_path)
            img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
            # add image to all_imgs
            all_imgs.append(img)

        return all_imgs

    def generate_img(self):
        """
        Generates an collage image based on Markov Chain and exports to appropriate output directory.

        :return: None
        """

        index = 0
        # retrieve a list of image objects that will be used
        all_imgs = self.get_all_imgs()
        # initialize rows array
        all_rows = []
        # create num_rows rows
        for r in range(self.num_rows):
            current_row = []
            # each row is of length num_cols
            for c in range(self.num_cols):
                # access id of current state in the order
                current_state_id = self.order[index].id
                # retrieve the image corresponding to that states id
                current_row.append(all_imgs[current_state_id])
                index += 1
            # create horizontal stack (row) of images
            current_row = np.hstack(current_row)
            all_rows.append(current_row)

        # concatenate rows into final image
        img = np.vstack(all_rows)

        # export image to output_path
        cv2.imwrite(self.output_path, img)


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('-i', '--input_dir', action='store', type=str, default=INPUT_DIR,
                        help=f'Specify name of input image directory --in_path=path. Default: {INPUT_DIR}',
                        dest='input_dir')
    parser.add_argument('-od', '--output_dir', action='store', type=str, default=OUTPUT_DIR,
                        help=f'Specify name of output directory. Default: {OUTPUT_DIR}',
                        dest='output_dir')
    parser.add_argument('-o', '--output_file', action='store', type=str, default=OUTPUT_FILENAME,
                        help=f'Specify name of output file. Default: {OUTPUT_FILENAME}',
                        dest='output_file')
    parser.add_argument('-d', '--img_dim', action='store', type=int, default=IMG_DIMS,
                        help=f'Specify dimensions of square image to be created. Default: {IMG_DIMS}',
                        dest='img_dims')

    args = parser.parse_args()

    sequence_length = args.img_dims ** 2

    # current working directory
    cwd = os.getcwd()

    # fix problem from running from different directory
    if "scripts" in cwd:
        cwd = cwd.replace("scripts", "")

    dog_names = DOG_NAMES

    # probability of the first pixel (upper left corner) is each dog
    prior = PRIOR

    # transition matrix
    transition = [ROSIE_TRANSITION, CALLIE_TRANSITION, VENUS_TRANSITION, BEAR_TRANSITION, JAMIE_TRANSITION,
                  COOPER_TRANSITION, WINSTON_TRANSITION, BRUNO_TRANSITION, MAISY_TRANSITION, SPEEDY_TRANSITION,
                  BELLA_TRANSITION, BOOMER_TRANSITION, SASHA_TRANSITION]

    all_states = []

    # create State object for each dog in dog names
    for i, dog in enumerate(dog_names):
        new_state = State(id=i, name=dog)
        all_states.append(new_state)

    # run markov chain using states, prior probability vector, and transition matrix
    m = MarkovChain(states=all_states, prior=prior, transition=transition)
    sequence = m.run(sequence_length=sequence_length)

    # create output_path variable
    output_path = os.path.join(cwd, args.output_dir)
    output_path = os.path.join(output_path, args.output_file)

    # generate image from markov chain, input images, and output_path
    i = ImgGenerator(order=sequence, input_dir=os.path.join(cwd, args.input_dir), output_path=output_path,
                     num_rows=args.img_dims,
                     num_cols=args.img_dims, all_states=all_states)
    i.generate_img()


if __name__ == '__main__':
    main()
