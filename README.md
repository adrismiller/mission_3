# Markov's Dogs 
This project uses a first order markov chain to generate a slightly altered version of pixel art. Pixel art can be created using markov chains by selecting a random color for the first pixel, and then selecting the next pixel color based on some conditional probability. These pixel colors represent states in a markov chain. Instead of pixels, I used images of dogs as states to create a collage like picture similar in spirit to pixel art. To create the markov chain, an initial state (dog picture) is selected based on the prior probability vector. From there, the next state (dog picture) is chosen based on the transition matrix entry from the previous state. 
## Set Up and Running Code. 

1. Go to terminal and clone git repository into a folder on computer  
    ```git clone https://github.com/adrismiller/mission_3.git ```
    
2. Use pip to install necessary requirements for project.  
    ``` pip install -r requirements.txt```
    
3. Confirm that you are in the correct directory, and navigate to mission_3 if not
    ``` cd mission_3 ``` 

4. Run generate.py in command line to randomly generate an image.  
    ```python scripts/generate.py``` 
    
5. Run with optional arguments: -i: string to specify input directory, -od: string to specify output directory, -o: string to specify output file (jpeg), -s: int specify Markov Chain sequence length, -d: int specify dimensions of img (img is always square)   
    ```python scripts/generate.py -i "input_photos" -od "outputs" -o "my_example_output" -s 400 -d 20```
    
## Project Code 
### state.py 
The state.py file contiains a class State to be referenced within the Markov Chain and while generating the image. This class has two parameters -- self.id, and self.name. 
### markov_chain.py 
The markov_chain.py file contains a class MarkovChain that is used to run a markov chain with the given input information. This class has 3 parameters --         self.states: an array of State objects to be used in the chain, self.prior: array with the prior probability vector, and self.transition: a 2D matrix containing the transition matrix. self.transition[i][j] is the probability that from State i, the markov chain will enter State j.  This class has 3 methods -- self.get_initial_state, self.get_new_state, and self.run. Self.get_initial_state returns a random State object based on the prior probability vector and self.get_new_state returns a new state to enter based on the transition matrix and the current state that the markov chain is in. Self.run uses both the other methods in the class to run a markov chain based on the given probabilities and returns the sequence of State objects generated. 

## generate.py
generate.py is the file used to generate the art image. The main method creates a MarkovChain object, runs a markov chain, and generates an image based on the markov chain created. generate.py contains the class ImgGenerator(). This class has several parameters -- all_states: a vector containing all possible State objects for the image to be generated, order:  vector containing the order (generated by MarkovChain) of state objects for the image, input_dir:  the directory containing input images, output_path: path that random image should be exported to, num_rows: number of rows that image will contain. ImgGenerator contains two methods -- get_all_imgs(), which uses the input directory and list of states to return an array of cv2 image objects. This method is used in the most important method of ImgGenerator, generate_img(). generate_img() uses the markov chain order passed into the class and the cv2 image objects to create the collage image in the correct order. 
   
## Discussion of Project 
   ### Personal Meaning 
   I decided pretty early on to do something involving pixel art for my project, but I struggled a little to decide what type of art I actually wanted to generate for this system. It's difficult to think of specific pieces of art that are meaningful to me, especially art that I could concievably use to generate something of my own. Ultimately, I decided to alter pixel art so that I would enjoy the final product of my system more. I collected pictures of my old and current dogs, and the dogs of my family and friends to create pixel art. I also used what I know about the different dogs relationships with each other to determine the probabilities that I put in the transition matrix. So, even though I may not be passionate about pixel art specifically, including images that were important to me gave the project more meaning.
   ## Challenges
   I had some  problems figuring out how to create the final image. A lot of the information I found about pixel art involved Pillow, and I had a difficult attempting to translate that to using images instead of pixels. Eventually I decided to switch to a library that was simpler to use for I what I wanted to do. I had some challenges working with cv2, since it is an old library (weird dependency issues) and it isn't as well documented as most the other python libraries I've used. This was a good challenge and lesson in learning how to work through a problem and use code that isn't very well documented or as commonly used. In the past, I've generally been able to find help on stack exchange or other websites for very specific errors, and it was more challenging to debug with less resources. I also had some challenges because I used pipenv for most of the project. I've worked a little bit with pipenv, but wanted to improve my skills in that area. While I was able to get more comfortable with pipenv, ultimately I decided not to include the Pipfile and related files in the project. Using a requirements.txt file made the download process simpler for others, and I wanted to make the repository easier to use. So, even though I wasn't entirely succesful in my work with pipenv, it was important to me to learn more about it and to at least become more comfortable on my own device with it. Setting up virtual environments isn't something I've been able to work on as much in CS classes at Bowdoin, and it was good to be able to advance in that way.  
   
Some next steps for this project could be creating the option for a higher order Markov Chain. Right now, there is only a first order Markov Chain, so the probability of entering a certain state depends only on the state immediately before it. I had hoped to implement an option for this in this version of the system, but I wasn't able to with the way that I hard-coded the probabilities. Next steps for this project would also include making the code a little more versatile. Most of the information on the input photos and states is hard coded into the generate.py method, and while it isn't difficult to edit, it could certainly be an easier process.
   ### Creativity 
   The two factors we discussed in our initial definition of creativity was novelty and value in the domain to which the work applies. This project fits that definition in a very specific domain. This system fits our definition of novel -- it expands on pixel art in a unique and interesting way. This project has value to me and my family because we enjoy silly photos and edits of our dogs. This system could be easily altered to include images that are meanginful to someone else, but is not likely to be that valuable on a level other than the personal. Another aspect of creativtiy we have discussed is the idea that each generation of art should be unique, and not replicable. All the examples images generated by my system have been unique. While it is unlikely that my system would create the same image twice with the default variables (the default length of the Markov Sequence is 400), if a user specified a much smaller length sequence, the art generated would be much less likely to be unique. 
   ## Sources 
   I talked a little bit with Nicole in the beginning stages of the project about what ideas we had for the art part of the system, as well as some specifics in the instructions. I used https://www.includehelp.com/python/create-a-collage-of-images-with-the-help-of-numpy-and-python-opencv-cv2.aspx as a guide to experiment and use cv2 to create my final images. I also used the documentation for common Python libraries (numpy, os). I had worked a little bit with argparse on an old projeect of mine, and used that as a reference for my code involving argparse. I also read this article about pixel art while I was thinking about different project ideas. https://magenta.as/using-machine-learning-to-make-art-84df7d3bb911 
